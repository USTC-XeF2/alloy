use std::any::{Any, TypeId};
use std::borrow::Cow;
use std::sync::Arc;

use futures::future::BoxFuture;
use tower::Service;
use tracing::{debug, error};

use crate::context::AlloyContext;
use crate::error::EventSkipped;
use crate::service::BoxedHandlerService;

// ─── PluginType ───────────────────────────────────────────────────────────────

/// Describes what functional role a plugin plays.
///
/// The value is **auto-inferred** by the [`define_plugin!`] macro:
/// - Plugins that declare a non-empty `provides` list → [`PluginType::Service`].
/// - All other plugins → [`PluginType::Runtime`].
///
/// The inferred value can be overridden by setting `plugin_type` inside the
/// `metadata` block:
///
/// ```rust,ignore
/// define_plugin! {
///     name: "my_plugin",
///     metadata: { plugin_type: service },
/// }
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PluginType {
    /// Plugin primarily registers shared services for other plugins to consume.
    Service,
    /// Plugin primarily handles events / has active runtime behaviour.
    Runtime,
}

// ─── PluginMetadata ───────────────────────────────────────────────────────────

/// Descriptive metadata attached to every plugin.
///
/// Populated automatically by the [`define_plugin!`] macro; values are derived
/// from build-environment constants and the optional `metadata` block.
///
/// # Defaults
///
/// | Field | Default |
/// |-------|---------|
/// | `version` | `CARGO_PKG_VERSION` of the crate that defined the plugin |
/// | `plugin_type` | auto-inferred from whether `provides` is non-empty |
/// | `desc` | `CARGO_PKG_DESCRIPTION` of the defining crate, or `""` |
/// | `full_desc` | `None` |
///
/// # Overriding via `define_plugin!`
///
/// ```rust,ignore
/// pub static MY: PluginDescriptor = define_plugin! {
///     name: "my_plugin",
///     metadata: {
///         version:     "2.0.0",
///         plugin_type: runtime,
///         desc:        "Short description.",
///         full_desc:   "Even longer description.",
///     },
///     handlers: [...],
/// };
/// ```
///
/// The `///` doc comment above `define_plugin!` (or above `name:`) is
/// captured as `full_desc` when `full_desc` is not set explicitly in the
/// `metadata` block.
#[derive(Debug, Clone, Copy)]
pub struct PluginMetadata {
    /// Semver version string of the plugin.
    pub version: &'static str,
    /// Functional role of the plugin (service-oriented vs. runtime/event-driven).
    pub plugin_type: PluginType,
    /// One-line description shown in logs and registries.
    pub desc: &'static str,
    /// Optional long-form description.
    pub full_desc: Option<&'static str>,
}

// ─── ServiceEntry ─────────────────────────────────────────────────────────────

/// One entry in a plugin's declared service list.
///
/// Generated by the [`define_plugin!`] macro for each item in `provides { … }`.
/// The [`PluginManager`] iterates these entries during `start_all` and calls
/// the factory to materialise + register each service in the global registry,
/// **before** the plugin's optional user-defined `on_load` block runs.
///
/// This ensures the manager has full control over what actually gets
/// registered — nothing can sneak in that wasn't declared in `provides`.
///
/// [`PluginManager`]: crate::manager::PluginManager
pub struct ServiceEntry {
    /// Service ID (matches the key in `defines_plugin! { provides: { <id>: Type } }`).
    pub id: &'static str,
    /// `TypeId` of the concrete service type; used by [`PluginManager`](crate::manager::PluginManager).
    pub type_id: TypeId,
    /// Async factory: receives the plugin config and returns a type-erased Arc.
    pub factory: Arc<
        dyn Fn(serde_json::Value) -> BoxFuture<'static, Arc<dyn Any + Send + Sync>> + Send + Sync,
    >,
}

// ─── Plugin ───────────────────────────────────────────────────────────────────

/// A live plugin instance bundling handlers, lifecycle hooks, and configuration.
///
/// Create via the [`define_plugin!`] macro.
///
/// # Concurrency
///
/// `Plugin` is `Send + Sync`.  Use interior mutability (e.g. `Arc<Mutex<T>>`)
/// for state that changes across events.
pub struct Plugin {
    pub(crate) name: Cow<'static, str>,
    /// Service IDs required before this plugin loads.
    pub(crate) depends_on: Vec<&'static str>,
    pub(crate) handlers: Vec<BoxedHandlerService>,

    /// Service factories generated by the [`define_plugin!`] macro.
    ///
    /// The service IDs that this plugin *provides* are derived from these
    /// entries (`entry.id`), so there is no separate `provides` list —
    /// the two can never get out of sync.
    ///
    /// [`PluginManager`] iterates these during `start_all`, calls every
    /// factory, then registers the result via
    /// factory, then inserts the result into the global service map.
    ///
    /// [`PluginManager`]: crate::manager::PluginManager
    pub(crate) service_factories: Vec<ServiceEntry>,

    pub(crate) on_load_fn:
        Option<Arc<dyn Fn(serde_json::Value) -> BoxFuture<'static, ()> + Send + Sync>>,
    pub(crate) on_unload_fn: Option<Arc<dyn Fn() -> BoxFuture<'static, ()> + Send + Sync>>,

    /// Descriptive metadata for this plugin instance.
    pub metadata: PluginMetadata,
}

impl Plugin {
    /// Returns the plugin's display name.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns the plugin's metadata.
    pub fn metadata(&self) -> &PluginMetadata {
        &self.metadata
    }

    /// Service IDs this plugin registers into the global registry.
    ///
    /// Derived on-demand from [`service_factories`](Self::service_factories)
    /// so the two can never get out of sync.
    pub fn provides(&self) -> Vec<&'static str> {
        self.service_factories.iter().map(|e| e.id).collect()
    }

    /// Service IDs this plugin requires before loading.
    pub fn depends_on(&self) -> &[&'static str] {
        &self.depends_on
    }

    /// Service factory entries declared by this plugin.
    ///
    /// The [`PluginManager`] iterates these during `start_all` to materialise
    /// and register each service in the global registry **before** calling
    /// [`on_load`](Self::on_load).
    ///
    /// [`PluginManager`]: crate::manager::PluginManager
    pub fn service_factories(&self) -> &[ServiceEntry] {
        &self.service_factories
    }

    /// Called once at startup.
    ///
    /// `config_json` is the plugin's section from `alloy.yaml`
    /// (or an empty object when absent).
    ///
    /// Service registration is handled automatically by [`PluginManager`]
    /// before this hook runs, so all declared `provides` are already available.
    ///
    /// [`PluginManager`]: crate::manager::PluginManager
    pub async fn on_load(&self, config_json: serde_json::Value) {
        if let Some(f) = &self.on_load_fn {
            f(config_json).await;
        }
    }

    /// Called for every incoming event.  Runs the handler chain.
    ///
    /// The runtime injects the plugin's raw config JSON into the context
    /// **before** calling this method, so handlers can use [`PluginConfig<T>`].
    pub async fn dispatch_event(&self, ctx: Arc<AlloyContext>) {
        for mut svc in self.handlers.iter().cloned() {
            if !ctx.is_propagating() {
                debug!(plugin = %self.name, "Propagation stopped, halting handler chain");
                break;
            }
            if let Err(e) = svc.call(ctx.clone()).await
                && !e.is::<EventSkipped>()
            {
                error!(
                    plugin = %self.name,
                    error  = %e,
                    "Handler returned an error"
                );
            }
        }
    }

    /// Called once at shutdown.
    pub async fn on_unload(&self) {
        if let Some(f) = &self.on_unload_fn {
            f().await;
        }
    }
}

// ─── Internal constructor (used by define_plugin! macro) ─────────────────────

impl Plugin {
    /// Creates a `Plugin` directly.  Only called by the [`define_plugin!`] macro.
    #[doc(hidden)]
    pub fn __new(
        name: &'static str,
        depends_on: Vec<&'static str>,
        handlers: Vec<BoxedHandlerService>,
        service_factories: Vec<ServiceEntry>,
        on_load_fn: Option<Arc<dyn Fn(serde_json::Value) -> BoxFuture<'static, ()> + Send + Sync>>,
        on_unload_fn: Option<Arc<dyn Fn() -> BoxFuture<'static, ()> + Send + Sync>>,
        metadata: PluginMetadata,
    ) -> Self {
        Plugin {
            name: Cow::Borrowed(name),
            depends_on,
            handlers,
            service_factories,
            on_load_fn,
            on_unload_fn,
            metadata,
        }
    }
}
